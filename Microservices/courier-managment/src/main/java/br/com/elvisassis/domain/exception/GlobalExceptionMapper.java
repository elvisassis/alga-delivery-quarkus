package br.com.elvisassis.domain.exception;import jakarta.ws.rs.BadRequestException;import jakarta.ws.rs.core.Context;import jakarta.ws.rs.core.Response;import jakarta.ws.rs.core.UriInfo;import jakarta.ws.rs.ext.ExceptionMapper;import jakarta.ws.rs.ext.Provider;import org.apache.kafka.common.errors.ResourceNotFoundException;import java.io.FileNotFoundException;import java.util.Date;import java.util.HashMap;import java.util.Map;@Providerpublic class GlobalExceptionMapper implements ExceptionMapper<Exception> {    @Context    UriInfo uriInfo;    // Mapeamento de exceções para status HTTP    private static Map<Class<? extends Exception>, Response.Status> STATUS_MAP = new HashMap<>();    static {        STATUS_MAP.put(ResourceNotFoundException.class, Response.Status.NOT_FOUND);        STATUS_MAP.put(BadRequestException.class, Response.Status.BAD_REQUEST);        STATUS_MAP.put(FileNotFoundException.class, Response.Status.NOT_FOUND);        STATUS_MAP.put(DomainException.class, Response.Status.INTERNAL_SERVER_ERROR);    }    @Override    public Response toResponse(Exception ex) {        // Busca o status HTTP no mapa, ou usa 500 como padrão        Response.Status status = STATUS_MAP.getOrDefault(ex.getClass(), Response.Status.INTERNAL_SERVER_ERROR);        String path = (uriInfo != null) ? uriInfo.getPath() : "path unavailable";        ExceptionResponse response = new ExceptionResponse(                new Date(),                ex.getMessage(),                path        );        return Response.status(status)                .entity(response)                .build();    }}